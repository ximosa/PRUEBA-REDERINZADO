
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¿Será WPGraphQL el próximo complemento canónico de WordPress?</title>
    <meta name="description" content="WPGraphQL ha ganado popularidad en el desarrollo de sitios desacoplados con WordPress, pero ¿se convertirá en un complemento canónico oficial? Descubre cómo est">
    <meta name="keywords" content="experto wordpress, trabajos wordpres, Web Full-Stack">
    <link href="https://cdn.jsdelivr.net/npm/beercss@3.7.12/dist/cdn/beer.min.css" rel="stylesheet">
</head>
<body>
    <div id="header"></div>
    <main class="medium-padding" style="max-width: 750px; margin: 0 auto">
        <a class="button border secondary" href="./blog">Volver al blog</a>
        <div id="post-content">
            <h1>¿Será WPGraphQL el próximo complemento canónico de WordPress?</h1>
            
<p>WPGraphQL ha ganado popularidad en el desarrollo de sitios desacoplados con WordPress, pero ¿se convertirá en un complemento canónico oficial? Descubre cómo esta poderosa herramienta podría redefinir la gestión de contenido en sitios headless y qué factores influirán en su adopción oficial dentro de WordPress.</p>



<figure class="wp-block-image aligncenter size-full is-resized"><img data-attachment-id="1526" data-permalink="https://expertoweb2.wordpress.com/2024/10/17/sera-wpgraphql-el-proximo-complemento-canonico-de-wordpress/bfa657e3-87b0-4c20-bb25-81592e4a5999/" data-orig-file="https://expertoweb2.wordpress.com/wp-content/uploads/2024/11/ecbbb-bfa657e3-87b0-4c20-bb25-81592e4a5999.webp" data-orig-size="1024,1024" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bfa657e3-87b0-4c20-bb25-81592e4a5999" data-image-description="" data-image-caption="" data-medium-file="https://expertoweb2.wordpress.com/wp-content/uploads/2024/11/ecbbb-bfa657e3-87b0-4c20-bb25-81592e4a5999.webp?w=300" data-large-file="https://expertoweb2.wordpress.com/wp-content/uploads/2024/11/ecbbb-bfa657e3-87b0-4c20-bb25-81592e4a5999.webp?w=1024" loading="lazy" width="1024" height="1024" src="https://expertoweb2.wordpress.com/wp-content/uploads/2024/11/ecbbb-bfa657e3-87b0-4c20-bb25-81592e4a5999.webp" alt="¿Será WPGraphQL el próximo complemento canónico de WordPress? " class="wp-image-1526" style="width:418px;height:auto" srcset="https://expertoweb2.wordpress.com/wp-content/uploads/2024/11/ecbbb-bfa657e3-87b0-4c20-bb25-81592e4a5999.webp 1024w, https://expertoweb2.wordpress.com/wp-content/uploads/2024/11/ecbbb-bfa657e3-87b0-4c20-bb25-81592e4a5999.webp?w=150&amp;h=150 150w, https://expertoweb2.wordpress.com/wp-content/uploads/2024/11/ecbbb-bfa657e3-87b0-4c20-bb25-81592e4a5999.webp?w=300&amp;h=300 300w, https://expertoweb2.wordpress.com/wp-content/uploads/2024/11/ecbbb-bfa657e3-87b0-4c20-bb25-81592e4a5999.webp?w=768&amp;h=768 768w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>





<h2 class="wp-block-heading">WPGraphQL: ¿Se convertirá en un complemento canónico de WordPress?</h2>



<p>WPGraphQL ha ganado una gran popularidad en la comunidad de desarrolladores de WordPress, especialmente entre aquellos que buscan crear sitios desacoplados (headless) o aprovechar frameworks modernos de JavaScript como React, Next.js o Gatsby para construir sus front-ends. Sin embargo, la pregunta sobre si WPGraphQL se convertirá en un complemento &#8220;canónico&#8221; de WordPress —es decir, una herramienta oficialmente respaldada y mantenida por el equipo central de WordPress— es un tema en evolución.</p>



<p class="has-base-background-color has-background">En el repositorio de GitHub, (<strong><a href="https://github.com/ximosa/expertowordpress"><code>expertowordpress</code></a>),</strong> encontrarás un ejemplo práctico de cómo implementar WPGraphQL utilizando únicamente HTML y JavaScript puro. Este enfoque evita el uso de frameworks que a menudo pueden ralentizar el rendimiento y complicar la creación de sitios estáticos ligeros y efectivos.</p>



<h3 class="wp-block-heading">¿Qué significa que un complemento sea canónico?</h3>



<p>En el ecosistema de WordPress, un complemento canónico es aquel que tiene el respaldo oficial de la comunidad y del equipo principal de desarrolladores de WordPress. Se considera una extensión casi estándar o esencial para ciertas funcionalidades. Por ejemplo, el plugin <strong>Jetpack</strong> es un complemento canónico porque es mantenido por Automattic, la empresa detrás de WordPress.com, y cuenta con una integración profunda con el ecosistema.</p>



<p>Para que un complemento se convierta en canónico, suele necesitar tener:</p>



<ol class="wp-block-list">
<li><strong>Un amplio respaldo y uso en la comunidad.</strong></li>



<li><strong>Un mantenimiento activo y de alta calidad.</strong></li>



<li><strong>Alineación con la visión del equipo principal de WordPress.</strong></li>



<li><strong>Un historial comprobado de seguridad, escalabilidad y eficiencia.</strong></li>
</ol>



<h3 class="wp-block-heading">Popularidad y respaldo de WPGraphQL</h3>



<p>WPGraphQL ha tenido un gran crecimiento desde su lanzamiento, principalmente porque resuelve una necesidad crítica para muchos desarrolladores: facilita la construcción de sitios desacoplados (headless) y permite interactuar con los datos de WordPress de manera más eficiente que la API REST tradicional.</p>



<p><strong>Ventajas que han impulsado su adopción:</strong></p>



<ul class="wp-block-list">
<li><strong>Consultas eficientes:</strong> GraphQL permite hacer consultas a la medida, solicitando solo los datos necesarios, lo que mejora el rendimiento en comparación con las respuestas de la API REST que pueden incluir más datos de los requeridos.</li>



<li><strong>Flexibilidad y control:</strong> Desarrolladores pueden definir exactamente cómo desean obtener los datos, y WPGraphQL es compatible con casi todos los tipos de contenido personalizados de WordPress.</li>



<li><strong>Integraciones con frameworks modernos:</strong> WPGraphQL es compatible con populares frameworks de generación de sitios estáticos y de front-end como Gatsby, Next.js y Nuxt.js, lo que facilita la construcción de sitios web modernos y rápidos.</li>
</ul>



<p>El plugin ha demostrado ser robusto y ha sido adoptado por empresas de alto perfil y proyectos grandes, lo que ha aumentado su credibilidad y confiabilidad dentro de la comunidad.</p>



<h3 class="wp-block-heading">¿Qué se necesitaría para que WPGraphQL sea canónico?</h3>



<p>Para que WPGraphQL sea considerado un complemento canónico, algunos de los pasos o factores clave podrían incluir:</p>



<ol class="wp-block-list">
<li><strong>Integración más profunda con el núcleo de WordPress:</strong><br>Aunque WPGraphQL funciona bien con la infraestructura actual de WordPress, no es una característica integrada directamente en el núcleo del sistema. Para convertirse en un complemento canónico, tendría que alinearse más estrechamente con las futuras versiones de WordPress. Esto podría significar una mayor integración oficial con la API REST o la posibilidad de incluir opciones de GraphQL en la instalación estándar de WordPress.</li>



<li><strong>Respaldo del equipo principal de WordPress o Automattic:</strong><br>Si WPGraphQL recibe el respaldo directo de Automattic, la empresa detrás de WordPress.com y el desarrollo central de WordPress, podría tener más probabilidades de convertirse en un estándar dentro del ecosistema. Automattic ha mostrado interés en tecnologías desacopladas (headless), y ya han surgido discusiones sobre la evolución de la API de WordPress, lo que podría abrir la puerta a una mayor adopción oficial de GraphQL.</li>



<li><strong>Una comunidad de desarrollo activa y sostenida:</strong><br>Aunque WPGraphQL ya cuenta con una base de usuarios y una comunidad de desarrolladores que contribuyen al proyecto, necesitaría un nivel constante de mantenimiento y evolución para cumplir con los estándares de un complemento canónico. Esto incluye asegurar la compatibilidad con futuras versiones de WordPress, mantener una excelente seguridad y proporcionar soporte técnico activo.</li>



<li><strong>Competencia o complemento a la API REST:</strong><br>Una consideración importante es la relación de WPGraphQL con la API REST oficial de WordPress. Actualmente, la API REST es la solución preferida y oficial para el acceso a datos desde WordPress, pero GraphQL ofrece beneficios claros en términos de optimización y flexibilidad. Para que WPGraphQL se convierta en canónico, podría ser necesario que WordPress adopte oficialmente una postura más abierta o inclusiva hacia GraphQL como una alternativa o complemento viable a la API REST.</li>
</ol>



<h3 class="wp-block-heading">Obstáculos para convertirse en un complemento canónico</h3>



<ol class="wp-block-list">
<li><strong>Filosofía del núcleo de WordPress:</strong><br>El equipo de WordPress ha mostrado preferencia por mantener la API REST como la solución predeterminada para acceder a los datos, ya que está alineada con las tecnologías web ampliamente usadas y es accesible para una gran variedad de desarrolladores. GraphQL, aunque potente, requiere un mayor nivel de conocimiento técnico, lo que podría limitar su adopción masiva entre los usuarios más casuales de WordPress.</li>



<li><strong>Competencia directa con la API REST:</strong><br>A pesar de que WPGraphQL es una excelente herramienta para desarrolladores avanzados, algunos en la comunidad de WordPress podrían ver esto como una competencia directa con la API REST, que ha sido una parte importante de la evolución de WordPress en los últimos años. Para que WPGraphQL sea canónico, probablemente necesitaría coexistir pacíficamente con la API REST sin reemplazarla.</li>



<li><strong>Curva de aprendizaje y enfoque técnico:</strong><br>WPGraphQL, aunque más eficiente, requiere que los desarrolladores comprendan y se familiaricen con GraphQL, lo que añade una curva de aprendizaje en comparación con la API REST. Esto podría ser visto como un desafío en una plataforma que ha estado orientada a usuarios no técnicos, y donde la sencillez ha sido siempre una prioridad.</li>
</ol>



<h3 class="wp-block-heading">Futuro de WPGraphQL: ¿Canónico o una herramienta de nicho?</h3>



<p>Aunque WPGraphQL podría no convertirse en un complemento canónico en el corto plazo, es claro que continuará siendo una herramienta influyente dentro del ecosistema de WordPress, especialmente para aquellos que buscan construir sitios desacoplados o aprovechar la flexibilidad de GraphQL.</p>



<p>A medida que más desarrolladores adopten modelos headless para construir sitios web dinámicos, la demanda de herramientas como WPGraphQL continuará creciendo. Esto podría empujar a la comunidad de WordPress y a Automattic a considerar una mayor integración o respaldo oficial.</p>



<p>En resumen, aunque WPGraphQL aún no es un complemento canónico, su relevancia en el espacio de desarrollo headless y su creciente comunidad sugieren que seguirá desempeñando un papel importante en el futuro de WordPress. La posibilidad de convertirse en una solución canónica dependerá de cómo evolucione la relación entre WordPress y las tecnologías headless, así como del apoyo que reciba de la comunidad y del equipo principal de desarrollo.</p>



<h2 class="wp-block-heading">WPGraphQL: Un puente entre WordPress y los sitios estáticos</h2>



<p>WPGraphQL es un plugin de WordPress que te permite interactuar con los datos de tu sitio web mediante una API GraphQL. A diferencia de la tradicional API REST de WordPress, GraphQL te da mayor control sobre qué datos solicitar y cómo recibirlos, optimizando el rendimiento al permitir obtener solo la información que necesitas en una única consulta.</p>



<p>Este plugin se ha vuelto especialmente útil para desarrolladores que quieren aprovechar la funcionalidad de WordPress como CMS sin depender de su interfaz tradicional para generar el front-end. Esto es particularmente relevante para quienes desarrollan sitios estáticos, ya que permite desacoplar el front-end del back-end. Así, puedes usar WordPress solo como gestor de contenido y desplegar tu sitio estático en frameworks modernos como Gatsby, Next.js o incluso con herramientas más simples como Hugo.</p>



<h3 class="wp-block-heading">Ventajas de usar WPGraphQL en un sitio estático</h3>



<ol class="wp-block-list">
<li><strong>Consulta eficiente de datos</strong><br>Con WPGraphQL, puedes realizar consultas precisas que solo traen la información específica que necesitas para cada página. Esto contrasta con las APIs REST tradicionales que, a menudo, entregan grandes cantidades de datos innecesarios, lo que puede afectar la velocidad y el rendimiento.</li>



<li><strong>Desempeño optimizado</strong><br>En un entorno estático, tu sitio no depende de un servidor que procese cada visita en tiempo real. Con WPGraphQL, puedes pre-renderizar tu sitio con los datos extraídos de WordPress y servirlo directamente desde un CDN (Red de Distribución de Contenidos). Esto hace que el sitio sea mucho más rápido y escalable.</li>



<li><strong>Desacoplamiento del front-end</strong><br>Al usar WPGraphQL, tienes la libertad de diseñar y desarrollar el front-end utilizando tecnologías modernas de JavaScript como React, Vue o Svelte, sin tener que lidiar con los sistemas de temas y plantillas de WordPress. Esto te permite ofrecer experiencias de usuario más dinámicas y personalizadas, y beneficiarte del ecosistema de librerías y herramientas de JavaScript.</li>



<li><strong>Compatibilidad con frameworks de sitios estáticos</strong><br>Algunos frameworks de generación de sitios estáticos, como Gatsby, tienen integraciones directas con WPGraphQL, lo que facilita la extracción de datos desde WordPress y su conversión en un sitio estático. Otras plataformas, como Next.js, también pueden utilizar WPGraphQL para obtener los datos del CMS durante la fase de pre-renderizado y generar páginas estáticas rápidas y seguras.</li>
</ol>



<h3 class="wp-block-heading">Cómo usar WPGraphQL en un sitio estático</h3>



<ol class="wp-block-list">
<li><strong>Instala el plugin WPGraphQL</strong><br>El primer paso es instalar y activar el plugin WPGraphQL en tu instalación de WordPress. Puedes hacerlo desde el panel de control de WordPress, navegando a <em>Plugins &gt; Añadir nuevo</em> y buscando &#8220;WPGraphQL&#8221;. Una vez activado, tendrás acceso a una interfaz de GraphQL desde <code>/graphql</code>.</li>



<li><strong>Familiarízate con GraphQL</strong><br>GraphQL te permite definir exactamente qué datos quieres recuperar, a diferencia de REST, que entrega conjuntos de datos más amplios. Puedes usar herramientas como GraphiQL, que viene integrada con WPGraphQL, para escribir y probar tus consultas. Por ejemplo, puedes pedir los últimos posts del blog, los campos personalizados de las entradas o cualquier otro tipo de contenido que hayas definido en WordPress.</li>



<li><strong>Conecta WPGraphQL con tu framework</strong><br>Dependiendo del framework que estés usando para tu sitio estático, deberás configurar la conexión entre WPGraphQL y el generador de sitios. En Gatsby, por ejemplo, puedes instalar el plugin <code>gatsby-source-graphql</code>, que permite conectar tu sitio estático con la API GraphQL de WordPress. Si estás usando Next.js, puedes usar la librería <code>apollo-client</code> para hacer consultas a WPGraphQL y traer los datos necesarios al pre-renderizar las páginas.</li>



<li><strong>Genera el sitio y despliega</strong><br>Una vez configurada la fuente de datos y creadas las consultas, puedes generar tu sitio estático. Este proceso depende del framework que estés usando, pero generalmente involucra un comando de construcción (<code>build</code>) que genera archivos HTML estáticos a partir de los datos consultados a WordPress. Luego, puedes desplegar el sitio en cualquier CDN o servicio de hosting estático como Netlify, Vercel o GitHub Pages.</li>
</ol>



<h3 class="wp-block-heading">Consideraciones adicionales</h3>



<p>Si bien WPGraphQL es poderoso, es importante tener en cuenta que puede requerir cierta curva de aprendizaje, especialmente si no estás familiarizado con GraphQL. Además, si tienes un sitio con mucha información dinámica o constante actualización, un sitio estático puede no ser la mejor solución, ya que la generación estática implica que el contenido no se actualiza automáticamente en tiempo real.</p>



<p>Sin embargo, en muchos casos, un sitio estático basado en WordPress y WPGraphQL ofrece una combinación ideal de gestión de contenido eficiente y entrega de sitio web ultrarrápida y segura.</p>



<h2 class="wp-block-heading">Hugo: Una opción más sencilla y rápida para sitios estáticos</h2>



<p>Hugo es uno de los generadores de sitios estáticos más populares, conocido por su simplicidad, velocidad y versatilidad. A diferencia de otros frameworks de generación estática como Gatsby o Next.js, Hugo se basa en Go, lo que le otorga una velocidad impresionante al generar sitios. Además, su enfoque directo y menos dependiente de JavaScript lo convierte en una excelente opción para quienes buscan construir sitios rápidos sin demasiadas complicaciones.</p>



<p>La simplicidad de Hugo radica en su filosofía de diseño y en cómo maneja los contenidos y las plantillas, lo que lo hace ideal para muchos desarrolladores y usuarios que quieren centrarse en la creación de contenido sin sobrecargarse con tecnologías adicionales.</p>



<h3 class="wp-block-heading">Razones por las que Hugo es más sencillo</h3>



<ol class="wp-block-list">
<li><strong>Estructura directa y mínima configuración</strong><br>Una de las principales razones por las que Hugo es más sencillo que otros generadores de sitios estáticos es su estructura de carpetas simple. Los usuarios pueden comenzar un proyecto con solo crear una carpeta y añadir contenido en formato Markdown (.md). Hugo no necesita de una configuración compleja o instalaciones de dependencias como otros frameworks basados en JavaScript, donde tienes que gestionar paquetes y configuraciones de compilación. En Hugo, los archivos se organizan de forma intuitiva: contenido, plantillas y activos estáticos están claramente separados, facilitando la navegación y el manejo del proyecto. Esta estructura clara permite que los usuarios se centren más en la creación de contenido en lugar de en la organización del código.</li>



<li><strong>Plantillas listas para usar y menos dependencias</strong><br>Hugo utiliza su propio sistema de plantillas basado en Go, lo que evita la necesidad de aprender o integrar librerías externas de JavaScript. Esto contrasta con frameworks como Gatsby o Next.js, que requieren la instalación y configuración de React o incluso bibliotecas adicionales para obtener funcionalidades comunes como el enrutamiento o el manejo de imágenes. Con Hugo, puedes utilizar las plantillas predeterminadas o personalizarlas según tus necesidades. Además, ofrece una amplia gama de temas preconstruidos que puedes instalar y usar de inmediato. Esto es especialmente útil para quienes desean construir sitios rápidos sin preocuparse por el diseño desde cero.</li>



<li><strong>Compatibilidad nativa con Markdown</strong><br>Hugo facilita enormemente la creación de contenido. Dado que está diseñado para trabajar principalmente con archivos Markdown, escribir publicaciones, páginas y cualquier otro contenido es muy sencillo. Markdown es un lenguaje de marcado simple que permite formatear texto sin tener que usar HTML. Esto significa que los usuarios pueden centrarse en la escritura en lugar de en la estructura del código. Por ejemplo, para crear una entrada de blog en Hugo, solo tienes que crear un archivo Markdown dentro de la carpeta <code>/content</code> y Hugo se encarga de formatearlo y publicarlo de acuerdo con las plantillas que hayas establecido.</li>



<li><strong>Velocidad de compilación</strong><br>Una de las mayores ventajas de Hugo es su velocidad. Al estar escrito en Go, Hugo es capaz de generar sitios completos en cuestión de milisegundos, incluso si contienen miles de páginas. Esta diferencia es notoria en comparación con generadores de sitios como Gatsby, que, debido a la naturaleza de React y la compilación de JavaScript, pueden tardar mucho más tiempo en generar archivos estáticos. Esto convierte a Hugo en la opción preferida para proyectos grandes o para aquellos que necesitan actualizar sitios con frecuencia y quieren minimizar el tiempo de generación.</li>
</ol>



<h3 class="wp-block-heading">Cómo empezar con Hugo fácilmente</h3>



<p>Si estás interesado en usar Hugo para un proyecto estático, el proceso de inicio es bastante sencillo:</p>



<ol class="wp-block-list">
<li><strong>Instalación</strong><br>Puedes instalar Hugo en tu máquina local fácilmente con un solo comando, dependiendo de tu sistema operativo. Si estás en macOS, por ejemplo, puedes usar <code>brew install hugo</code>. En Windows, puedes descargar el ejecutable o instalarlo a través de un gestor de paquetes como Chocolatey.</li>



<li><strong>Creación de un nuevo proyecto</strong><br>Una vez instalado, puedes iniciar un nuevo proyecto con el comando <code>hugo new site nombre-del-sitio</code>. Esto generará una estructura de carpetas básica que incluye una carpeta para el contenido, las plantillas, los datos y los activos estáticos.</li>



<li><strong>Añadir un tema</strong><br>Puedes elegir entre una variedad de temas disponibles en la comunidad de Hugo. Para agregar uno, simplemente clona el repositorio del tema en la carpeta <code>/themes</code> de tu proyecto y configúralo en tu archivo <code>config.toml</code>.</li>



<li><strong>Escribir contenido</strong><br>Para crear una nueva página o entrada, simplemente usa el comando <code>hugo new</code> seguido del tipo de contenido que deseas crear, como <code>hugo new posts/mi-primer-post.md</code>. Luego, puedes abrir el archivo Markdown y escribir tu contenido.</li>



<li><strong>Previsualización y compilación</strong><br>Hugo ofrece un servidor de previsualización que puedes ejecutar con el comando <code>hugo server</code>. Esto te permite ver los cambios en tiempo real mientras desarrollas tu sitio. Una vez que estés listo para publicar, puedes ejecutar <code>hugo</code> para generar el sitio estático completo, listo para ser desplegado en cualquier servidor o CDN.</li>
</ol>



<h3 class="wp-block-heading">Hugo versus otros generadores de sitios estáticos</h3>



<p>Comparado con otros generadores de sitios como Gatsby, que requiere una comprensión más profunda de React y del ecosistema de JavaScript, Hugo destaca por ser más accesible para aquellos que no están tan familiarizados con tecnologías avanzadas. Aunque Hugo no es tan modular en términos de interactividad del cliente (como lo es React en Gatsby), es perfecto para sitios que no necesitan componentes altamente dinámicos.</p>



<p>Para muchos proyectos, la simplicidad de Hugo, su velocidad y el bajo mantenimiento de su configuración lo convierten en la elección más práctica y eficiente.</p>



<h3 class="wp-block-heading">¿Es Hugo la opción correcta para ti?</h3>



<p>Si tu principal objetivo es crear un sitio rápido, ligero y fácil de mantener sin las complejidades de JavaScript, Hugo es una excelente opción. Su estructura directa, junto con la compatibilidad nativa con Markdown, lo hacen ideal para sitios de contenido estático como blogs, portafolios y documentación.</p>



<h2 class="wp-block-heading">Conectar WPGraphQL con Hugo: </h2>



<p><strong>Gestiona WordPress como backend en tu sitio estático</strong></p>



<p>Si quieres aprovechar WordPress como CMS para administrar contenido, pero utilizar Hugo para generar y desplegar un sitio estático ultrarrápido, conectar WPGraphQL con Hugo puede ser una solución potente. Esta integración te permite mantener la familiaridad y facilidad de uso de WordPress como backend, pero aprovechar la velocidad y simplicidad de Hugo como generador de sitios.</p>



<p>Aunque Hugo no tiene una integración nativa con WPGraphQL, puedes conectar ambas herramientas utilizando algunas técnicas y librerías para extraer el contenido desde WordPress y luego compilarlo como parte de tu sitio estático.</p>



<h3 class="wp-block-heading">Ventajas de conectar WPGraphQL con Hugo</h3>



<ol class="wp-block-list">
<li><strong>Separación del front-end y el back-end</strong><br>Al desacoplar el contenido de la presentación, puedes usar WordPress como plataforma de gestión de contenido (CMS) mientras Hugo se encarga de generar el front-end estático. Esto es ideal si quieres mantener el flujo de trabajo de publicación de contenido simple en WordPress, pero disfrutar de un sitio rápido y seguro con Hugo.</li>



<li><strong>Rendimiento optimizado</strong><br>Una vez que Hugo genera el sitio estático con los datos de WordPress, puedes desplegarlo en una CDN, lo que garantiza tiempos de carga rápidos y menos vulnerabilidades de seguridad en comparación con un sitio dinámico de WordPress.</li>



<li><strong>Flexibilidad en el diseño del front-end</strong><br>Hugo te permite diseñar tu front-end utilizando su motor de plantillas, sin las limitaciones de los temas de WordPress. Además, al extraer solo los datos necesarios desde WPGraphQL, tienes total control sobre cómo y cuándo mostrar la información en tu sitio.</li>
</ol>



<h3 class="wp-block-heading">Pasos para conectar WPGraphQL con Hugo</h3>



<p>A continuación te explico el proceso básico para conectar WPGraphQL con Hugo, lo cual implica obtener los datos de WordPress y alimentarlos a Hugo para que genere tu sitio estático.</p>



<h4 class="wp-block-heading">1. Instala y configura WPGraphQL en WordPress</h4>



<p>Lo primero que necesitas es asegurarte de que WPGraphQL esté correctamente instalado y configurado en tu instalación de WordPress:</p>



<ul class="wp-block-list">
<li>Ve a tu panel de WordPress.</li>



<li>Dirígete a la sección de <em>Plugins</em> y busca &#8220;WPGraphQL&#8221;.</li>



<li>Instálalo y actívalo. Una vez activado, puedes acceder a la API de GraphQL en <code>/graphql</code>.</li>
</ul>



<p>Desde este punto, podrás realizar consultas a la API GraphQL para extraer los datos de WordPress que desees, como entradas, páginas, categorías y cualquier campo personalizado que hayas configurado.</p>



<h4 class="wp-block-heading">2. Familiarízate con WPGraphQL y las consultas</h4>



<p>Antes de extraer los datos para tu sitio Hugo, es recomendable que te familiarices con las consultas en WPGraphQL. Puedes usar la herramienta integrada <em>GraphiQL</em> en el plugin de WPGraphQL para hacer pruebas y construir tus consultas. Por ejemplo, una consulta básica para obtener las últimas publicaciones del blog se vería algo así:</p>



<pre class="wp-block-code"><code>{
  posts {
    nodes {
      title
      date
      content
      slug
    }
  }
}</code></pre>



<p>Esta consulta recupera el título, la fecha, el contenido y el slug de las entradas de blog. Puedes adaptarla según las necesidades de tu sitio Hugo.</p>



<h4 class="wp-block-heading">3. Extrae los datos de WPGraphQL</h4>



<p>El siguiente paso es extraer los datos de WordPress para alimentarlos a Hugo. Para hacerlo, tienes dos métodos principales:</p>



<p><strong>Método 1: Script personalizado para extraer los datos</strong><br>Una forma común es crear un script personalizado (por ejemplo, en Node.js o Go) que haga consultas a la API WPGraphQL, guarde los resultados en formato JSON o Markdown, y los coloque en la carpeta <code>/content</code> de Hugo. Esto permite que Hugo utilice estos archivos como fuente de contenido al generar el sitio.</p>



<p>Aquí tienes un ejemplo básico de un script en Node.js que podría hacer una consulta a WPGraphQL y guardar las entradas de blog como archivos Markdown:</p>



<pre class="wp-block-code"><code>const fetch = require('node-fetch');
const fs = require('fs');

async function fetchPosts() {
  const res = await fetch('https://tusitio.com/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      query: `
        {
          posts {
            nodes {
              title
              date
              content
              slug
            }
          }
        }
      `,
    }),
  });

  const { data } = await res.json();

  data.posts.nodes.forEach(post =&gt; {
    const content = `---
title: "${post.title}"
date: "${post.date}"
slug: "${post.slug}"
---
${post.content}
`;

    fs.writeFileSync(`./content/posts/${post.slug}.md`, content);
  });
}

fetchPosts();</code></pre>



<p>Este script hace una consulta a WPGraphQL para obtener las entradas y luego crea archivos <code>.md</code> con el contenido de cada entrada en la carpeta <code>/content/posts</code> de Hugo.</p>



<p><strong>Método 2: Usar un plugin externo</strong><br>Si prefieres no escribir tu propio script, hay herramientas como <code>wp2static</code> o plugins que ayudan a exportar el contenido de WordPress en formato estático. Estos plugins pueden integrar directamente con APIs, como WPGraphQL, y generar los archivos estáticos de una manera más automatizada.</p>



<h4 class="wp-block-heading">4. Configura Hugo para que utilice los archivos generados</h4>



<p>Una vez que hayas extraído los datos de WordPress como archivos Markdown o JSON, Hugo los tomará y los procesará como cualquier otro contenido. Asegúrate de que tus plantillas de Hugo estén configuradas para mostrar correctamente los campos que has extraído de WordPress.</p>



<p>Por ejemplo, si estás generando posts con el formato Markdown, tus plantillas de Hugo para los posts podrían verse algo así:</p>



<pre class="wp-block-code"><code>&lt;article&gt;
  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;
  &lt;p&gt;Publicado el {{ .Date }}&lt;/p&gt;
  &lt;div&gt;{{ .Content }}&lt;/div&gt;
&lt;/article&gt;</code></pre>



<p>Este simple código mostrará el título, la fecha y el contenido de las entradas que has extraído de WPGraphQL.</p>



<h4 class="wp-block-heading">5. Genera y despliega tu sitio Hugo</h4>



<p>Después de haber configurado Hugo para utilizar los datos de WordPress, el último paso es generar el sitio estático y desplegarlo. Puedes hacer esto con el comando <code>hugo</code>, que generará los archivos HTML estáticos en la carpeta <code>/public</code>.</p>



<p>Luego, puedes desplegar estos archivos en cualquier CDN o servicio de hosting estático como Netlify, Vercel, GitHub Pages o tu propio servidor.</p>



<h3 class="wp-block-heading">Consideraciones adicionales</h3>



<ol class="wp-block-list">
<li><strong>Actualización de contenido</strong><br>Si el contenido de tu WordPress cambia con frecuencia, deberás ejecutar periódicamente el script o el plugin que extrae los datos de WPGraphQL para mantener tu sitio Hugo actualizado.</li>



<li><strong>Seguridad</strong><br>Recuerda que con este enfoque, tu WordPress puede estar expuesto a ataques si no está bien asegurado. Al desacoplar el front-end y usar Hugo como sitio estático, reducirás el riesgo, pero WordPress seguirá siendo una parte importante que deberás proteger.</li>
</ol>



<h3 class="wp-block-heading">Conclusión</h3>



<p>Conectar WPGraphQL con Hugo es una excelente opción para combinar lo mejor de ambos mundos: la gestión de contenido dinámica de WordPress y la generación ultrarrápida y segura de Hugo. Aunque requiere configurar un flujo de trabajo personalizado, los beneficios en términos de rendimiento, flexibilidad y seguridad valen la pena para muchos proyectos.</p>

        </div>
    </main>
    <div id="footer"></div>
    <script type="module" src="https://cdn.jsdelivr.net/npm/beercss@3.7.12/dist/cdn/beer.min.js"></script>
    <script src="script.js"></script>
    <script src="main.js"></script>
</body>
</html>